struct header{
	int 		tamano del nombre;
	tipo_raro 	modo;
	tipo_raro 	uid;
	tipo_raro 	gid;
	string 		uname;
	string 		gname;
	int 		size;
	int 		num_blocks;
	tipo_raro 	link_flag;	
	string	 	link_name;
	char 		*name;
}

tar.c {

	void writeAux(){ //ready
	   hace write;
	}

	int_to_char(int x){ //ready
		return arreglo de 4 caracteres que representan x;
	}

	cifrarString(char * str, int len){ //ready
		FOR(char str[i] en str){
			str[i] = rotarChar(str[i]);
		}
	}
	
	void get_header(char * path_and_name,  header *h) // listo
	{
		sacar vainas de stat
	}

	char * header_to_string(header * h){ // listo
		hace el string
		if(flag rota) rota el string
		return a string con el contenido del header.
	}

	void guardar_data(int fd, char * ruta){ // listo
		conseguir fd2;
		writeAux(fd, get_string_data(fd2));
		close(fd2);
	}

	void guardar_header(header * h, int fd){	// listo
		write_aux(fd, tamano_string_header, header_to_string(h));
	}

	void empaquetar_dir(int fd, header *, char * ruta){

		FOR(archivo (hijo) en el directorio){
			header h;
			get_header(ruta / nombrehijo,  &h );
			guardar_header(&h, ruta / nombrehijo);
			if(es dir) empaquetar_dir(fd, &h, ruta / nombrehijo)
			else if(es reg) guardar_data(fd, ruta / nombrehijo)
		}
	}

	void empaquetar( int fd1 , int fd2 )
	{
		
		int fd;
		fd = open( "nombre", crear | escribir | truncar "});
		FOR(archivo en el input){
			header h;
			get_header( &h , fd );
			guardar_header(&h, nombreArchivo);
			if(es dir) empaquetar_dir(fd, &h, nombreArchivo)
			else if(es reg) guardar_data(fd, nombreArchivo)
		}

		close(fd);
		
	}
}

untar.c
{
	descifrarString(char * str, int len){ // listoo
    	FOR(char str[i] en str){
      		str[i] = rotarChar(str[i]);
    	}
  	}

	read_header( int fd )
	{
		header h;
		string s1 , s2;
		leer las cosas que tienen tamano conocido y almacernarlo en h;
		if ( descrifrado ) descifrarString( s1 , l1);
		con el tamano del nombre ya leido leer el nombre y guardarlo en h;
		if ( descrifrado ) descifrarString( s2 , l2);
		return h;
	}

	descomprimir( int fd )
	{
		int fd;
		header h;
		while ( read != eof )
		{
			read_header( int fd );
			if ( dir )
			{
				mkdir( ... );
			}
			if ( link )
			{
				symlink( ... );
			}
			if ( pipe )
			{
				mkfifo( ... );
			}
			if ( regular )
			{
				fd2 = open( ... , create | write );
				loaddata( fd , fd2 , size );
				close(fd2);
			}
		}
	}

	loaddata( int fd , int fd2 , int size )
	{
		int read_count = 0;
		char buff[size];
		while ( read_count < size )
		{
			int l2 = read( fd , buff , size );
			read_count += l2;
			int l1 = 0;
			while ( l1 < l2 )
			{
				l1 += write( fd2 , buff + l1 , l2 - l1);
			}
		}
	}
}

main.c {
	
	//

}